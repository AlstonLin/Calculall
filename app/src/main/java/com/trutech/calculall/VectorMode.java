package com.trutech.calculall;

import android.view.View;
import android.widget.ToggleButton;

import java.util.ArrayList;

/**
 * Contains the back-end for Vector Mode. The mode will be able to compute most vector
 * problems in a grade twelve level.
 *
 * @author Alston Lin, Keith Wong, Jason Fok
 * @version Alpha 2.0
 */

public class VectorMode extends Advanced {
    private static final String FILENAME = "history_vector";
    private static final Basic INSTANCE = new VectorMode();

    { //pseudo-constructor
        filename = "history_vector";
    }

    private boolean mem = false;

    /**
     * Allows for the Singleton pattern so there would be only one instance.
     *
     * @return The singleton instance
     */
    public static Basic getInstance() {
        return INSTANCE;
    }

    /**
     * When a Button has been clicked, calls the appropriate method.
     *
     * @param v The Button that has been clicked
     */
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.var_u:
                clickU();
                break;
            case R.id.var_v:
                clickV();
                break;
            case R.id.var_t:
                clickVT();
                break;
            case R.id.var_s:
                clickVS();
                break;
            case R.id.add_button:
                clickAdd();
                break;
            case R.id.subtract_button:
                clickSubtract();
                break;
            case R.id.angle_between_vectors:
                clickAngle();
                break;
            case R.id.magnitude_open_button:
                clickMagnitudeOpen();
                break;
            case R.id.magnitude_close_button:
                clickMagnitudeClose();
                break;
            case R.id.unit_vector:
                clickUnitVector();
                break;
            case R.id.scalar_equation:
                clickScalar();
                break;
            case R.id.open_square_bracket:
                clickOpenSquareBracket();
                break;
            case R.id.closed_square_button:
                clickCloseSquareBracket();
                break;
            case R.id.dot_button:
                clickDot();
                break;
            case R.id.cross_button:
                clickCross();
                break;
            case R.id.equals_button:
                clickVectorEquals();
                break;
            case R.id.comma_button:
                clickComma();
                break;
            default:
                super.onClick(v);
        }
    }


    public void clickAdd() {
        tokens.add(display.getRealCursorIndex(), VectorOperatorFactory.makeAdd());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    public void clickSubtract() {
        tokens.add(display.getRealCursorIndex(), VectorOperatorFactory.makeSubtract());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    private void clickCross() {
        tokens.add(display.getRealCursorIndex(), VectorOperatorFactory.makeCross());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    private void clickDot() {
        tokens.add(display.getRealCursorIndex(), VectorOperatorFactory.makeDot());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    private void clickAngle() {
        tokens.add(display.getRealCursorIndex(), VectorOperatorFactory.makeAngle());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    public void clickU() {
        if (mem) {
            storeVector("→ U", new Command<Void, Token>() {
                @Override
                public Void execute(Token val) {
                    VectorVariable.uValue = val;
                    return null;
                }
            });
        } else {
            tokens.add(display.getRealCursorIndex(), VectorVariableFactory.makeU());
            display.setCursorIndex(display.getCursorIndex() + 1);
            updateInput();
        }
    }

    public void clickV() {
        if (mem) {
            storeVector("→ V", new Command<Void, Token>() {
                @Override
                public Void execute(Token val) {
                    VectorVariable.vValue = val;
                    return null;
                }
            });
        } else {
            tokens.add(display.getRealCursorIndex(), VectorVariableFactory.makeV());
            display.setCursorIndex(display.getCursorIndex() + 1);
            updateInput();
        }
    }

    /**
     * When the user presses the equals Button in Vector Mode.
     */
    public void clickVectorEquals() {
        try {
            ArrayList<Token> toOutput = VectorUtilities.processVectors(tokens);
            display.displayOutput(toOutput);
            activity.scrollDown();
            saveEquation(tokens, toOutput, FILENAME);
        } catch (Exception e) { //User did a mistake
            handleExceptions(e);
        }
    }

    /**
     * When the user presses the MEM button; toggles memory storage
     */
    public void clickMem() {
        ToggleButton vMemButton = (ToggleButton) activity.findViewById(R.id.mem_button);
        mem = !mem;
        vMemButton.setChecked(mem);
    }


    /**
     * Stores the a variable into the memory; the assignment itself will occur in the given Command.
     *
     * @param addToOutput The String that will be shown in the output along with the value
     * @param assignment  The assignment command that would be executed
     */
    protected void storeVector(String addToOutput, Command<Void, Token> assignment) {
        DisplayView display = (DisplayView) activity.findViewById(R.id.display);
        ToggleButton memButton = (ToggleButton) activity.findViewById(R.id.mem_button);
        try {
            ArrayList<Token> output = VectorUtilities.processVectors(tokens); //Should only have 1 Vector result
            assignment.execute(output.get(0));

            output.add(new StringToken(addToOutput));
            display.displayOutput(output);
            mem = false;
            memButton.setChecked(false);
        } catch (Exception e) { //User did a mistake
            handleExceptions(e);
        }
    }


    /**
     * When the user presses the T button.
     */
    public void clickVT() {
        tokens.add(display.getRealCursorIndex(), VectorVariableFactory.makeT());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    /**
     * When the user presses the S button.
     */
    public void clickVS() {
        tokens.add(display.getRealCursorIndex(), VectorVariableFactory.makeS());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }


    /**
     * When the user presses the [ Button.
     */
    public void clickOpenSquareBracket() {
        tokens.add(display.getRealCursorIndex(), BracketFactory.makeOpenSquareBracket());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    /**
     * When the user presses the ] Button.
     */
    public void clickCloseSquareBracket() {
        tokens.add(display.getRealCursorIndex(), BracketFactory.makeCloseSquareBracket());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    /**
     * When the user presses the ||( Button.
     */
    public void clickMagnitudeOpen() {
        tokens.add(display.getRealCursorIndex(), BracketFactory.makeMagnitudeOpen());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    /**
     * When the user presses the )|| Button.
     */
    public void clickMagnitudeClose() {
        tokens.add(display.getRealCursorIndex(), BracketFactory.makeMagnitudeClose());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    /**
     * When the user presses the , Button.
     */
    public void clickComma() {
        tokens.add(display.getRealCursorIndex(), PlaceholderFactory.makeComma());
        display.setCursorIndex(display.getCursorIndex() + 1);
        updateInput();
    }

    /**
     * When the user presses the , Button.
     */
    public void clickUnitVector() {
        Token function = VectorFunctionFactory.makeUnit();
        Token bracket = BracketFactory.makeOpenBracket();
        function.addDependency(bracket);
        bracket.addDependency(function);
        tokens.add(display.getRealCursorIndex(), function);
        tokens.add(display.getRealCursorIndex() + 1, bracket);
        display.setCursorIndex(display.getCursorIndex() + 2);
        updateInput();
    }

    /**
     * When the user presses the Scalar Button.
     */
    public void clickScalar() {
        try {
            ArrayList<Token> tokens = VectorUtilities.parseVectors(VectorUtilities.setupVectorExpression(Utility.setupExpression(Utility.condenseDigits(VectorUtilities.subVariables(this.tokens)))));
            //Checks if it is 2D or 3D
            ArrayList<Token> constantTerms = new ArrayList<>();
            ArrayList<Token> directionVectorsS = new ArrayList<>();
            ArrayList<Token> directionVectorsT = new ArrayList<>();
            for (int i = 0; i < tokens.size(); i++) {
                Token t = tokens.get(i);
                if (t instanceof VectorVariable && t.getType() == VectorVariable.T) {
                    i++; //Goes to the next token
                    //If the Vector is right after
                    if (i < tokens.size() && tokens.get(i) instanceof Vector) {
                        directionVectorsT.add(tokens.get(i));
                    } else if (i < tokens.size() && tokens.get(i) instanceof Bracket && tokens.get(i).getType() == Bracket.OPEN) { //If the Vector is in a bracketed expression
                        int bracketCount = -1;
                        i++;
                        ArrayList<Token> inside = new ArrayList<>();
                        while (i < tokens.size() && bracketCount < 0) {
                            Token token = tokens.get(i);
                            if (token instanceof Bracket && token.getType() == Bracket.OPEN) {
                                bracketCount--;
                            } else if (token instanceof Bracket && token.getType() == Bracket.CLOSE) {
                                bracketCount++;
                            }
                            inside.add(token);
                            i++;
                        }
                        directionVectorsT.addAll(inside);
                    }
                } else if (t instanceof VectorVariable && t.getType() == VectorVariable.S) {
                    i++; //Goes to the next token
                    //If the Vector is right after
                    if (i < tokens.size() && tokens.get(i) instanceof Vector) {
                        directionVectorsS.add(tokens.get(i));
                    } else if (i < tokens.size() && tokens.get(i) instanceof Bracket && tokens.get(i).getType() == Bracket.OPEN) { //If the Vector is in a bracketed expression
                        int bracketCount = -1;
                        i++;
                        ArrayList<Token> inside = new ArrayList<>();
                        while (i < tokens.size() && bracketCount < 0) {
                            Token token = tokens.get(i);
                            if (token instanceof Bracket && token.getType() == Bracket.OPEN) {
                                bracketCount--;
                            } else if (token instanceof Bracket && token.getType() == Bracket.CLOSE) {
                                bracketCount++;
                            }
                            inside.add(token);
                            i++;
                        }
                        directionVectorsS.addAll(inside);
                    }
                } else if (t instanceof VectorOperator && t.getType() == VectorOperator.ADD && i + 1 < tokens.size() && tokens.get(i + 1) instanceof VectorVariable) { //Ignores addition before s & t
                    //Do nothing
                } else {
                    constantTerms.add(t);
                }
            }
            //Now evaluates all the expressions
            ArrayList<Token> result1 = VectorUtilities.processVectors(directionVectorsT);
            ArrayList<Token> result2 = VectorUtilities.processVectors(directionVectorsS);
            Token t1 = result1.size() == 0 ? null : result1.get(0);
            Token t2 = result2.size() == 0 ? null : result2.get(0);

            if (constantTerms.size() > 0 && constantTerms.get(0) instanceof VectorOperator) { //Removes any front operators in the constant terms first
                VectorOperator o = (VectorOperator) constantTerms.remove(0);
                if (o.getType() == VectorOperator.ADD) {
                    //Deos nothing
                } else if (o.getType() == VectorOperator.SUBTRACT) {
                    constantTerms.add(0, VectorOperatorFactory.makeCross());
                    constantTerms.add(0, new Number(-1));
                } else { //Only ADD and SUBTRACT are valid
                    throw new IllegalArgumentException("Illegal Vector Equation of line / plane");
                }
            }
            ArrayList<Token> constantResults = VectorUtilities.processVectors(constantTerms);
            double[] zeroVector = {0, 0, 0};
            Token constant = constantResults.size() == 0 ? new Vector(zeroVector) : constantResults.get(0);
            if (!(constant instanceof Vector)) { //Constant must be a Vector
                throw new IllegalArgumentException("Illegal Vector Equation of line / plane");
            }

            if (t1 != null && t2 != null) { //3D
                if (t1 instanceof Vector && t2 instanceof Vector) {
                    //Makes sure theyre all 3D vectors
                    if (((Vector) t1).getDimensions() != 3 || ((Vector) t2).getDimensions() != 3 || ((Vector) constant).getDimensions() != 3) {
                        throw new IllegalArgumentException("The vectors in the scalar equation of a plane must be in 3D");
                    }
                    ArrayList<Token> scalar = VectorUtilities.calculateScalarEquationPlane3D((Vector) constant, (Vector) t1, (Vector) t2);
                    display.displayOutput(scalar);
                    activity.scrollDown();
                    //Saves the output
                    ArrayList<Token> toOutput = new ArrayList<>();
                    toOutput.add(new StringToken("Scalar of "));
                    toOutput.addAll(scalar);
                    try {
                        saveEquation(tokens, toOutput, FILENAME);
                    } catch (Exception e) { //User did a mistake
                        handleExceptions(e);
                    }
                } else {
                    throw new IllegalArgumentException("Illegal Vector Equation of plane");
                }
            } else if (t1 != null) {
                if (t1 instanceof Vector) {
                    if (((Vector) t1).getDimensions() != 2 || (((Vector) constant).getDimensions() != 2 && VectorUtilities.calculateMagnitude((Vector) constant) != 0)) {
                        throw new IllegalArgumentException("Can only have a scalar equation of a line in 2D");
                    }
                    ArrayList<Token> scalar = VectorUtilities.calculateScalarEquationLine((Vector) constant, (Vector) t1);
                    display.displayOutput(scalar);
                    activity.scrollDown();
                    //Saves the output
                    ArrayList<Token> toOutput = new ArrayList<>();
                    toOutput.add(new StringToken("Scalar of "));
                    toOutput.addAll(scalar);
                    try {
                        saveEquation(tokens, toOutput, FILENAME);
                    } catch (Exception e) { //User did a mistake
                        handleExceptions(e);
                    }
                } else {
                    throw new IllegalArgumentException("Illegal Vector Equation of line");
                }
            } else if (t2 != null) {
                if (t2 instanceof Vector) {
                    if (((Vector) t2).getDimensions() != 2 || (((Vector) constant).getDimensions() != 2 && VectorUtilities.calculateMagnitude((Vector) constant) != 0)) {
                        throw new IllegalArgumentException("Can only have a scalar equation of a line in 2D");
                    }
                    ArrayList<Token> scalar = VectorUtilities.calculateScalarEquationLine((Vector) constant, (Vector) t2);
                    display.displayOutput(scalar);
                    activity.scrollDown();
                    //Saves the output
                    ArrayList<Token> toOutput = new ArrayList<>();
                    toOutput.add(new StringToken("Scalar of "));
                    toOutput.addAll(scalar);
                    try {
                        saveEquation(tokens, toOutput, FILENAME);
                    } catch (Exception e) { //User did a mistake
                        handleExceptions(e);
                    }
                } else {
                    throw new IllegalArgumentException("Illegal Vector Equation of line");
                }
            } else {
                throw new IllegalArgumentException("Vector equations must include arbitrary variables (s/t)");
            }
        } catch (Exception e) {
            handleExceptions(e);
        }
    }

}